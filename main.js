/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => NanoBananaPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/settingsData.ts
var DEFAULT_SETTINGS = {
  // API Keys
  googleApiKey: "",
  openaiApiKey: "",
  anthropicApiKey: "",
  xaiApiKey: "",
  // Prompt Generation
  selectedProvider: "google",
  promptModel: "gemini-2.5-flash",
  // Best price-performance ratio
  // Image Generation
  imageModel: "gemini-3-pro-image-preview",
  imageStyle: "infographic",
  preferredLanguage: "ko",
  imageQuality: "high",
  // 2K resolution, good balance of quality and speed
  // UX Settings
  showPreviewBeforeGeneration: true,
  attachmentFolder: "999-Attachments",
  autoRetryCount: 2,
  showProgressModal: true,
  // Advanced
  customPromptPrefix: ""
};
var SYSTEM_PROMPT = `You are a world-class visual designer specializing in educational infographics, knowledge visualization, and data storytelling. You have won multiple design awards and your work has been featured in top publications.

Your mission: Transform complex information into visually stunning, instantly understandable knowledge posters that captivate viewers and enhance learning.

## Your Design Philosophy
- **Clarity First**: Every element serves a purpose. Remove anything that doesn't enhance understanding.
- **Visual Hierarchy**: Guide the viewer's eye naturally from most important to supporting details.
- **Emotional Impact**: Create designs that evoke curiosity, wonder, and the joy of learning.
- **Professional Polish**: Deliver gallery-quality work suitable for publication.

## Output Requirements
Generate ONLY the image generation prompt. No explanations, no preamble, no additional commentary.

## Prompt Structure (Follow This Exactly)
Your prompt must include these elements in order:

1. **Format & Orientation**: Specify poster dimensions and orientation
2. **Visual Style**: Define the overall aesthetic (e.g., "modern minimalist", "elegant scientific", "bold editorial")
3. **Color Palette**: Describe specific colors or color relationships
4. **Layout Structure**: Describe the compositional framework
5. **Typography Hierarchy**: Specify heading styles, body text treatment
6. **Key Visual Elements**: Icons, illustrations, diagrams, or data visualizations
7. **Content Placement**: Where key information appears
8. **Mood & Atmosphere**: The emotional quality of the design
9. **Quality Markers**: Include "4K", "ultra-detailed", "professional quality"

## Critical Guidelines
- Keep text in the image MINIMAL (titles, key terms only - the visual should do the explaining)
- Use METAPHORICAL VISUALS to represent abstract concepts
- Create VISUAL CONNECTIONS between related ideas
- Ensure HIGH CONTRAST for readability
- Design for IMMEDIATE COMPREHENSION - viewer should grasp the main idea in 3 seconds
- Include WHITE SPACE strategically for visual breathing room
- Make it SHARE-WORTHY - something people would want to save or print

## Quality Standard
The resulting image should look like it was created by a professional design agency charging $5,000+ per poster.`;
var IMAGE_GENERATION_PROMPT_TEMPLATE = `Create a premium, award-winning knowledge poster with these specifications:

## VISUAL STYLE
{style}

## CONTENT TO VISUALIZE
{prompt}

## MANDATORY DESIGN SPECIFICATIONS

### Layout & Composition
- Vertical poster format, 2:3 aspect ratio
- Golden ratio-based layout for natural visual flow
- Clear focal point in the upper third
- Generous margins and breathing room
- Maximum 3-4 distinct content zones

### Typography (CRITICAL)
- Large, bold headline that captures the essence (max 5-7 words visible)
- Elegant sans-serif for headings, clean serif or sans for any body text
- Strong typographic hierarchy with clear size differentiation
- Text must be crisp, readable, and properly kerned
- Limit visible text to: 1 headline + 3-5 key terms/labels maximum

### Color & Visual Treatment
- Sophisticated, limited color palette (3-4 colors max)
- Rich gradients or subtle textures for depth
- Strategic use of accent color for emphasis
- Ensure WCAG AA contrast compliance
- Cohesive, professional color harmony

### Visual Elements
- Custom iconography or illustrations that explain concepts visually
- Smooth, vector-quality graphics
- Visual metaphors that make abstract ideas tangible
- Subtle shadows, highlights, and dimensional effects
- NO stock photo clich\xE9s - original, conceptual visuals only

### Quality Requirements
- 4K resolution, ultra-sharp details
- Professional print-ready quality
- Suitable for framing and display
- Gallery-worthy aesthetic
- Clean, polished, premium finish

The final result should look like a $10,000 custom design piece from a top creative agency.`;

// src/settings.ts
var import_obsidian = require("obsidian");

// src/types.ts
var PROVIDER_CONFIGS = {
  openai: {
    name: "OpenAI",
    endpoint: "https://api.openai.com/v1/chat/completions",
    defaultModel: "gpt-5.1",
    models: [
      {
        id: "gpt-5.1",
        name: "GPT-5.1",
        tier: "flagship",
        description: "Latest flagship with advanced reasoning and coding tools",
        contextWindow: 4e5,
        supportsVision: true
      },
      {
        id: "gpt-5-pro",
        name: "GPT-5 Pro",
        tier: "flagship",
        description: "Highest reasoning level for complex analysis",
        contextWindow: 4e5,
        supportsVision: true
      },
      {
        id: "gpt-5-mini",
        name: "GPT-5 Mini",
        tier: "balanced",
        description: "Cost-optimized reasoning and chat",
        contextWindow: 4e5,
        supportsVision: true
      },
      {
        id: "gpt-5-nano",
        name: "GPT-5 Nano",
        tier: "fast",
        description: "High-throughput, simple instruction-following",
        contextWindow: 4e5
      },
      {
        id: "gpt-4o",
        name: "GPT-4o",
        tier: "balanced",
        description: "Reliable multimodal model with vision",
        contextWindow: 128e3,
        supportsVision: true
      },
      {
        id: "gpt-4o-mini",
        name: "GPT-4o Mini",
        tier: "fast",
        description: "Fast and cost-effective for simpler tasks",
        contextWindow: 128e3,
        supportsVision: true
      },
      {
        id: "o3-mini",
        name: "o3 Mini",
        tier: "balanced",
        description: "Fast reasoning model for STEM tasks",
        contextWindow: 2e5
      }
    ]
  },
  google: {
    name: "Google Gemini",
    endpoint: "https://generativelanguage.googleapis.com/v1beta/models",
    defaultModel: "gemini-2.5-flash",
    models: [
      {
        id: "gemini-3-pro-preview",
        name: "Gemini 3 Pro",
        tier: "flagship",
        description: "Most powerful agentic model with rich visuals",
        contextWindow: 1048576,
        supportsVision: true
      },
      {
        id: "gemini-2.5-pro",
        name: "Gemini 2.5 Pro",
        tier: "flagship",
        description: "Full-featured with thinking and code execution",
        contextWindow: 1048576,
        supportsVision: true
      },
      {
        id: "gemini-2.5-flash",
        name: "Gemini 2.5 Flash",
        tier: "balanced",
        description: "Best price-performance ratio with thinking",
        contextWindow: 1048576,
        supportsVision: true
      },
      {
        id: "gemini-2.5-flash-lite",
        name: "Gemini 2.5 Flash-Lite",
        tier: "fast",
        description: "Fastest and most cost-effective option",
        contextWindow: 1048576,
        supportsVision: true
      },
      {
        id: "gemini-2.0-flash",
        name: "Gemini 2.0 Flash",
        tier: "fast",
        description: "Stable fast model for production",
        contextWindow: 1048576,
        supportsVision: true
      },
      {
        id: "gemini-1.5-pro",
        name: "Gemini 1.5 Pro",
        tier: "balanced",
        description: "Ultra long context (2M tokens)",
        contextWindow: 2097152,
        supportsVision: true
      }
    ]
  },
  anthropic: {
    name: "Anthropic Claude",
    endpoint: "https://api.anthropic.com/v1/messages",
    defaultModel: "claude-sonnet-4-5-20250929",
    models: [
      {
        id: "claude-opus-4-5-20251101",
        name: "Claude 4.5 Opus",
        tier: "flagship",
        description: "Most powerful Claude ever, superior reasoning",
        contextWindow: 2e5,
        supportsVision: true
      },
      {
        id: "claude-sonnet-4-5-20250929",
        name: "Claude 4.5 Sonnet",
        tier: "flagship",
        description: "Best balance of power and speed",
        contextWindow: 2e5,
        supportsVision: true
      },
      {
        id: "claude-sonnet-4-20250514",
        name: "Claude Sonnet 4",
        tier: "balanced",
        description: "Excellent for complex tasks",
        contextWindow: 2e5,
        supportsVision: true
      },
      {
        id: "claude-3-5-sonnet-20241022",
        name: "Claude 3.5 Sonnet",
        tier: "balanced",
        description: "Reliable balance of speed and intelligence",
        contextWindow: 2e5,
        supportsVision: true
      },
      {
        id: "claude-3-opus-20240229",
        name: "Claude 3 Opus",
        tier: "balanced",
        description: "Powerful for complex analysis",
        contextWindow: 2e5,
        supportsVision: true
      },
      {
        id: "claude-3-haiku-20240307",
        name: "Claude 3 Haiku",
        tier: "fast",
        description: "Fastest Claude, great for simple tasks",
        contextWindow: 2e5,
        supportsVision: true
      }
    ]
  },
  xai: {
    name: "xAI Grok",
    endpoint: "https://api.x.ai/v1/chat/completions",
    defaultModel: "grok-4-1-fast",
    models: [
      {
        id: "grok-4-1-fast",
        name: "Grok 4.1 Fast",
        tier: "flagship",
        description: "Latest multimodal with function calling, 2M context",
        contextWindow: 2e6
      },
      {
        id: "grok-4-0709",
        name: "Grok 4",
        tier: "flagship",
        description: "Powerful reasoning model with structured outputs",
        contextWindow: 256e3
      },
      {
        id: "grok-3",
        name: "Grok 3",
        tier: "balanced",
        description: "Capable model with function calling",
        contextWindow: 131072
      },
      {
        id: "grok-3-mini",
        name: "Grok 3 Mini",
        tier: "balanced",
        description: "Cost-effective with reasoning",
        contextWindow: 131072
      },
      {
        id: "grok-code-fast-1",
        name: "Grok Code Fast",
        tier: "fast",
        description: "Optimized for coding tasks",
        contextWindow: 256e3
      },
      {
        id: "grok-2-vision-1212",
        name: "Grok 2 Vision",
        tier: "vision",
        description: "Vision-enabled for image understanding",
        contextWindow: 32768,
        supportsVision: true
      }
    ]
  }
};
function getModelInfo(provider, modelId) {
  return PROVIDER_CONFIGS[provider].models.find((m) => m.id === modelId);
}
var IMAGE_STYLES = {
  infographic: `Modern data-driven infographic style:
- Clean geometric shapes and data visualization elements
- Icon-based explanations with connecting lines
- Statistical charts, graphs, and comparison tables
- Flat design with strategic 3D accents
- Bold section dividers and visual categorization
- Number callouts and percentage indicators
- Professional corporate aesthetic with editorial polish`,
  poster: `Bold editorial poster design:
- Dramatic typography as the primary visual element
- High-contrast color blocking
- Powerful central imagery or abstract visualization
- Magazine-quality layout and composition
- Artistic negative space utilization
- Statement-making visual hierarchy
- Museum exhibition-worthy aesthetic`,
  diagram: `Technical explanatory diagram style:
- Clean flowchart and process visualization
- Annotated components with leader lines
- Isometric or orthographic projections where applicable
- Blueprint/schematic aesthetic with modern refinement
- Step-by-step visual sequences
- Cross-sections and exploded views
- Engineering precision with design elegance`,
  mindmap: `Organic mind map visualization:
- Central concept with radiating branches
- Organic, flowing connection lines
- Hierarchical node sizing based on importance
- Color-coded categories and groupings
- Illustrated icons at key nodes
- Natural growth pattern aesthetic
- Brain-friendly visual organization`,
  timeline: `Elegant chronological timeline design:
- Horizontal or vertical progression axis
- Milestone markers with visual distinction
- Period/era color coding
- Event illustrations or icons
- Clear date/time annotations
- Historical document aesthetic with modern clarity
- Museum exhibition panel quality`
};
var LANGUAGE_NAMES = {
  ko: "\uD55C\uAD6D\uC5B4 (Korean)",
  en: "English",
  ja: "\u65E5\u672C\u8A9E (Japanese)",
  zh: "\u4E2D\u6587 (Chinese)",
  es: "Espa\xF1ol (Spanish)",
  fr: "Fran\xE7ais (French)",
  de: "Deutsch (German)"
};
var QUALITY_LABELS = {
  standard: { name: "Standard (1K)", description: "1024px - Fast generation, lower detail" },
  high: { name: "High (2K)", description: "2048px - Recommended for most use cases" },
  ultra: { name: "Ultra (4K)", description: "4096px - Maximum detail, Gemini 3 Pro only" }
};

// src/settings.ts
var NanoBananaSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  /**
   * Format context window size for display
   */
  formatContextWindow(tokens) {
    if (!tokens)
      return "N/A";
    if (tokens >= 1e6) {
      return `${(tokens / 1e6).toFixed(1)}M tokens`;
    }
    return `${(tokens / 1e3).toFixed(0)}K tokens`;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "\u{1F34C} NanoBanana PRO Settings" });
    containerEl.createEl("h2", { text: "\u{1F511} API Keys" });
    new import_obsidian.Setting(containerEl).setName("Google API Key").setDesc("Required for image generation. Get your key from Google AI Studio.").addText(
      (text) => text.setPlaceholder("Enter your Google API key").setValue(this.plugin.settings.googleApiKey).onChange(async (value) => {
        this.plugin.settings.googleApiKey = value;
        await this.plugin.saveSettings();
      })
    ).addExtraButton(
      (button) => button.setIcon("external-link").setTooltip("Get API Key").onClick(() => {
        window.open("https://aistudio.google.com/apikey");
      })
    );
    new import_obsidian.Setting(containerEl).setName("OpenAI API Key").setDesc("Optional. Used for prompt generation if OpenAI is selected.").addText(
      (text) => text.setPlaceholder("Enter your OpenAI API key").setValue(this.plugin.settings.openaiApiKey).onChange(async (value) => {
        this.plugin.settings.openaiApiKey = value;
        await this.plugin.saveSettings();
      })
    ).addExtraButton(
      (button) => button.setIcon("external-link").setTooltip("Get API Key").onClick(() => {
        window.open("https://platform.openai.com/api-keys");
      })
    );
    new import_obsidian.Setting(containerEl).setName("Anthropic API Key").setDesc("Optional. Used for prompt generation if Anthropic is selected.").addText(
      (text) => text.setPlaceholder("Enter your Anthropic API key").setValue(this.plugin.settings.anthropicApiKey).onChange(async (value) => {
        this.plugin.settings.anthropicApiKey = value;
        await this.plugin.saveSettings();
      })
    ).addExtraButton(
      (button) => button.setIcon("external-link").setTooltip("Get API Key").onClick(() => {
        window.open("https://console.anthropic.com/settings/keys");
      })
    );
    new import_obsidian.Setting(containerEl).setName("xAI API Key").setDesc("Optional. Used for prompt generation if xAI is selected.").addText(
      (text) => text.setPlaceholder("Enter your xAI API key").setValue(this.plugin.settings.xaiApiKey).onChange(async (value) => {
        this.plugin.settings.xaiApiKey = value;
        await this.plugin.saveSettings();
      })
    ).addExtraButton(
      (button) => button.setIcon("external-link").setTooltip("Get API Key").onClick(() => {
        window.open("https://console.x.ai/");
      })
    );
    containerEl.createEl("h2", { text: "\u{1F916} Prompt Generation" });
    new import_obsidian.Setting(containerEl).setName("AI Provider").setDesc("Select which AI provider to use for generating image prompts.").addDropdown(
      (dropdown) => dropdown.addOptions({
        "google": "\u{1F310} Google Gemini",
        "openai": "\u{1F916} OpenAI",
        "anthropic": "\u{1F9E0} Anthropic Claude",
        "xai": "\u26A1 xAI Grok"
      }).setValue(this.plugin.settings.selectedProvider).onChange(async (value) => {
        this.plugin.settings.selectedProvider = value;
        this.plugin.settings.promptModel = PROVIDER_CONFIGS[value].defaultModel;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    const providerConfig = PROVIDER_CONFIGS[this.plugin.settings.selectedProvider];
    const currentModelInfo = getModelInfo(this.plugin.settings.selectedProvider, this.plugin.settings.promptModel);
    const modelOptions = {};
    providerConfig.models.forEach((model) => {
      const tierEmoji = model.tier === "flagship" ? "\u2B50" : model.tier === "balanced" ? "\u2696\uFE0F" : model.tier === "vision" ? "\u{1F441}\uFE0F" : "\u26A1";
      modelOptions[model.id] = `${tierEmoji} ${model.name}`;
    });
    const modelSetting = new import_obsidian.Setting(containerEl).setName("Prompt Model").setDesc(currentModelInfo ? `${currentModelInfo.description} \u2022 Context: ${this.formatContextWindow(currentModelInfo.contextWindow)}` : "Select a model for prompt generation").addDropdown(
      (dropdown) => dropdown.addOptions(modelOptions).setValue(this.plugin.settings.promptModel).onChange(async (value) => {
        this.plugin.settings.promptModel = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    const legendDiv = containerEl.createDiv({ cls: "nanobanana-model-legend" });
    legendDiv.innerHTML = `
      <small style="color: var(--text-muted); display: flex; gap: 12px; margin-top: -8px; margin-bottom: 16px;">
        <span>\u2B50 Flagship</span>
        <span>\u2696\uFE0F Balanced</span>
        <span>\u26A1 Fast</span>
        <span>\u{1F441}\uFE0F Vision</span>
      </small>
    `;
    containerEl.createEl("h2", { text: "\u{1F5BC}\uFE0F Image Generation" });
    new import_obsidian.Setting(containerEl).setName("Image Model").setDesc("Google Gemini model for image generation. Must support image output.").addText(
      (text) => text.setPlaceholder("gemini-3-pro-image-preview").setValue(this.plugin.settings.imageModel).onChange(async (value) => {
        this.plugin.settings.imageModel = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Image Style").setDesc("Default style for generated posters.").addDropdown(
      (dropdown) => dropdown.addOptions({
        "infographic": "\u{1F4CA} Infographic - Charts, icons, visual hierarchy",
        "poster": "\u{1F3A8} Poster - Bold typography, strong imagery",
        "diagram": "\u{1F4D0} Diagram - Technical, clear connections",
        "mindmap": "\u{1F9E0} Mind Map - Central concept with branches",
        "timeline": "\u{1F4C5} Timeline - Progression and milestones"
      }).setValue(this.plugin.settings.imageStyle).onChange(async (value) => {
        this.plugin.settings.imageStyle = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Preferred Language").setDesc("Language for text in generated images (e.g., titles, labels, descriptions).").addDropdown(
      (dropdown) => dropdown.addOptions({
        "ko": "\u{1F1F0}\u{1F1F7} \uD55C\uAD6D\uC5B4 (Korean)",
        "en": "\u{1F1FA}\u{1F1F8} English",
        "ja": "\u{1F1EF}\u{1F1F5} \u65E5\u672C\u8A9E (Japanese)",
        "zh": "\u{1F1E8}\u{1F1F3} \u4E2D\u6587 (Chinese)",
        "es": "\u{1F1EA}\u{1F1F8} Espa\xF1ol (Spanish)",
        "fr": "\u{1F1EB}\u{1F1F7} Fran\xE7ais (French)",
        "de": "\u{1F1E9}\u{1F1EA} Deutsch (German)"
      }).setValue(this.plugin.settings.preferredLanguage).onChange(async (value) => {
        this.plugin.settings.preferredLanguage = value;
        await this.plugin.saveSettings();
      })
    );
    const currentQuality = QUALITY_LABELS[this.plugin.settings.imageQuality];
    new import_obsidian.Setting(containerEl).setName("Image Quality").setDesc(currentQuality ? currentQuality.description : "Select image resolution.").addDropdown(
      (dropdown) => dropdown.addOptions({
        "standard": "\u{1F4F1} Standard (1K) - Fast",
        "high": "\u{1F5A5}\uFE0F High (2K) - Recommended",
        "ultra": "\u{1F3A8} Ultra (4K) - Maximum quality"
      }).setValue(this.plugin.settings.imageQuality).onChange(async (value) => {
        this.plugin.settings.imageQuality = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    containerEl.createEl("h2", { text: "\u2699\uFE0F User Experience" });
    new import_obsidian.Setting(containerEl).setName("Show Preview Before Generation").setDesc("Show the generated prompt and allow editing before creating the image.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showPreviewBeforeGeneration).onChange(async (value) => {
        this.plugin.settings.showPreviewBeforeGeneration = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Show Progress Modal").setDesc("Display a progress indicator during generation.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showProgressModal).onChange(async (value) => {
        this.plugin.settings.showProgressModal = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Attachment Folder").setDesc("Folder to save generated images. Will be created if it doesn't exist.").addText(
      (text) => text.setPlaceholder("999-Attachments").setValue(this.plugin.settings.attachmentFolder).onChange(async (value) => {
        this.plugin.settings.attachmentFolder = value || "999-Attachments";
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Auto-Retry Count").setDesc("Number of automatic retries on transient failures (0-5).").addSlider(
      (slider) => slider.setLimits(0, 5, 1).setValue(this.plugin.settings.autoRetryCount).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.autoRetryCount = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "\u{1F527} Advanced" });
    new import_obsidian.Setting(containerEl).setName("Custom Prompt Prefix").setDesc("Optional text to prepend to all generated prompts.").addTextArea(
      (textarea) => textarea.setPlaceholder('e.g., "Create in a minimalist style with blue color scheme..."').setValue(this.plugin.settings.customPromptPrefix).onChange(async (value) => {
        this.plugin.settings.customPromptPrefix = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "\u2139\uFE0F About" });
    const aboutDiv = containerEl.createDiv({ cls: "nanobanana-about" });
    aboutDiv.createEl("p", {
      text: "NanoBanana PRO v1.0.0"
    });
    aboutDiv.createEl("p", {
      text: "Generate beautiful Knowledge Posters from your notes using AI."
    });
    const linksDiv = aboutDiv.createDiv({ cls: "nanobanana-links" });
    linksDiv.createEl("a", {
      text: "\u{1F4D6} Documentation",
      href: "https://github.com/username/nanobanana-pro-obsidian#readme"
    });
    linksDiv.createEl("span", { text: " | " });
    linksDiv.createEl("a", {
      text: "\u{1F41B} Report Issue",
      href: "https://github.com/username/nanobanana-pro-obsidian/issues"
    });
  }
};

// src/services/promptService.ts
var import_obsidian2 = require("obsidian");
var USER_MESSAGE_TEMPLATE = `## Task
Analyze the following content and generate a professional image generation prompt for a knowledge poster/infographic.

## Content to Visualize
---
{content}
---

## Style Preference
{style}

## Language Requirement
The poster should use {language} for any text elements (titles, labels, annotations).

## Analysis Instructions
1. First, identify the CORE CONCEPT - what is the single most important idea?
2. Extract 3-5 KEY SUPPORTING POINTS that explain or expand on the core concept
3. Identify any DATA, NUMBERS, or COMPARISONS that could be visualized
4. Consider what VISUAL METAPHORS could represent abstract ideas
5. Determine the optimal VISUAL HIERARCHY for the information

## Output
Generate a single, detailed, professional image generation prompt that will result in a gallery-worthy knowledge poster. The prompt should be comprehensive (200-400 words) and include specific visual, compositional, and stylistic details.

Remember: Generate ONLY the prompt, no explanations or preamble.`;
var PromptService = class {
  /**
   * Generate an image prompt from note content using the specified AI provider
   */
  async generatePrompt(noteContent, provider, model, apiKey, style, language) {
    if (!apiKey) {
      throw this.createError("INVALID_API_KEY", `${PROVIDER_CONFIGS[provider].name} API key is not configured`);
    }
    if (!noteContent.trim()) {
      throw this.createError("NO_CONTENT", "Note content is empty");
    }
    const userMessage = this.buildUserMessage(noteContent, style, language);
    try {
      const prompt = await this.callProvider(provider, model, apiKey, userMessage);
      const cleanedPrompt = this.postProcessPrompt(prompt);
      return {
        prompt: cleanedPrompt,
        model,
        provider
      };
    } catch (error) {
      if (error.type) {
        throw error;
      }
      throw this.handleApiError(error, provider);
    }
  }
  /**
   * Build an enhanced user message with style and language preferences
   */
  buildUserMessage(content, style, language) {
    const styleDescription = style ? IMAGE_STYLES[style] : IMAGE_STYLES["infographic"];
    const languageName = language ? LANGUAGE_NAMES[language] : LANGUAGE_NAMES["en"];
    const processedContent = this.preprocessContent(content);
    return USER_MESSAGE_TEMPLATE.replace("{content}", processedContent).replace("{style}", styleDescription).replace("{language}", languageName);
  }
  /**
   * Preprocess content to optimize for prompt generation
   */
  preprocessContent(content) {
    let processed = content.replace(/\n{3,}/g, "\n\n").trim();
    processed = processed.replace(/!\[.*?\]\(.*?\)/g, "");
    processed = processed.replace(/<!--.*?-->/gs, "");
    if (processed.length > 8e3) {
      processed = processed.slice(0, 6e3) + "\n\n[...content truncated...]\n\n" + processed.slice(-2e3);
    }
    return processed;
  }
  /**
   * Post-process the generated prompt to ensure quality
   */
  postProcessPrompt(prompt) {
    let cleaned = prompt.replace(/^(Here's|Here is|Below is|I've created|I have created)[^:]*:/i, "").replace(/^(Sure|Certainly|Of course)[^:]*[.:]/i, "").trim();
    cleaned = cleaned.replace(/^```[a-z]*\n?/i, "").replace(/\n?```$/i, "");
    if (!cleaned.match(/^(Create|Design|Generate|A |An |The )/i)) {
      cleaned = "Create " + cleaned.charAt(0).toLowerCase() + cleaned.slice(1);
    }
    return cleaned.trim();
  }
  async callProvider(provider, model, apiKey, userMessage) {
    switch (provider) {
      case "openai":
        return this.callOpenAI(model, apiKey, userMessage);
      case "google":
        return this.callGoogle(model, apiKey, userMessage);
      case "anthropic":
        return this.callAnthropic(model, apiKey, userMessage);
      case "xai":
        return this.callXAI(model, apiKey, userMessage);
      default:
        throw this.createError("UNKNOWN", `Unknown provider: ${provider}`);
    }
  }
  async callOpenAI(model, apiKey, userMessage) {
    var _a, _b, _c;
    const response = await (0, import_obsidian2.requestUrl)({
      url: "https://api.openai.com/v1/chat/completions",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model,
        messages: [
          { role: "system", content: SYSTEM_PROMPT },
          { role: "user", content: userMessage }
        ],
        max_tokens: 1500,
        temperature: 0.75
      })
    });
    if (response.status !== 200) {
      throw this.handleHttpError(response.status, response.text, "openai");
    }
    const data = response.json;
    return ((_c = (_b = (_a = data.choices[0]) == null ? void 0 : _a.message) == null ? void 0 : _b.content) == null ? void 0 : _c.trim()) || "";
  }
  async callGoogle(model, apiKey, userMessage) {
    var _a, _b, _c, _d, _e, _f;
    const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
    const response = await (0, import_obsidian2.requestUrl)({
      url,
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: `${SYSTEM_PROMPT}

${userMessage}`
          }]
        }],
        generationConfig: {
          temperature: 0.75,
          maxOutputTokens: 1500
        }
      })
    });
    if (response.status !== 200) {
      throw this.handleHttpError(response.status, response.text, "google");
    }
    const data = response.json;
    return ((_f = (_e = (_d = (_c = (_b = (_a = data.candidates) == null ? void 0 : _a[0]) == null ? void 0 : _b.content) == null ? void 0 : _c.parts) == null ? void 0 : _d[0]) == null ? void 0 : _e.text) == null ? void 0 : _f.trim()) || "";
  }
  async callAnthropic(model, apiKey, userMessage) {
    var _a, _b, _c;
    const response = await (0, import_obsidian2.requestUrl)({
      url: "https://api.anthropic.com/v1/messages",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": apiKey,
        "anthropic-version": "2023-06-01"
      },
      body: JSON.stringify({
        model,
        max_tokens: 1500,
        system: SYSTEM_PROMPT,
        messages: [
          { role: "user", content: userMessage }
        ]
      })
    });
    if (response.status !== 200) {
      throw this.handleHttpError(response.status, response.text, "anthropic");
    }
    const data = response.json;
    return ((_c = (_b = (_a = data.content) == null ? void 0 : _a[0]) == null ? void 0 : _b.text) == null ? void 0 : _c.trim()) || "";
  }
  async callXAI(model, apiKey, userMessage) {
    var _a, _b, _c;
    const response = await (0, import_obsidian2.requestUrl)({
      url: "https://api.x.ai/v1/chat/completions",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model,
        messages: [
          { role: "system", content: SYSTEM_PROMPT },
          { role: "user", content: userMessage }
        ],
        max_tokens: 1500,
        temperature: 0.75
      })
    });
    if (response.status !== 200) {
      throw this.handleHttpError(response.status, response.text, "xai");
    }
    const data = response.json;
    return ((_c = (_b = (_a = data.choices[0]) == null ? void 0 : _a.message) == null ? void 0 : _b.content) == null ? void 0 : _c.trim()) || "";
  }
  handleHttpError(status, responseText, provider) {
    if (status === 401 || status === 403) {
      return this.createError("INVALID_API_KEY", `Invalid ${PROVIDER_CONFIGS[provider].name} API key`);
    }
    if (status === 429) {
      return this.createError("RATE_LIMIT", "API rate limit exceeded. Please wait and try again.", true);
    }
    if (status >= 500) {
      return this.createError("NETWORK_ERROR", "Server error. Please try again later.", true);
    }
    return this.createError("GENERATION_FAILED", `API error: ${responseText}`);
  }
  handleApiError(error, provider) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    if (errorMessage.includes("net::") || errorMessage.includes("network")) {
      return this.createError("NETWORK_ERROR", "Network connection error. Check your internet connection.", true);
    }
    return this.createError("GENERATION_FAILED", `${PROVIDER_CONFIGS[provider].name} error: ${errorMessage}`);
  }
  createError(type, message, retryable = false) {
    return { type, message, retryable };
  }
};

// src/services/imageService.ts
var import_obsidian3 = require("obsidian");
var ASPECT_RATIO_CONFIG = {
  infographic: "2:3",
  // Vertical infographic
  poster: "2:3",
  // Vertical poster
  diagram: "4:3",
  // Slightly wide diagram
  mindmap: "1:1",
  // Square mindmap
  timeline: "16:9"
  // Wide timeline
};
var ImageService = class {
  /**
   * Generate an infographic image using Google Gemini
   */
  async generateImage(prompt, apiKey, model, style, preferredLanguage, quality = "high") {
    if (!apiKey) {
      throw this.createError("INVALID_API_KEY", "Google API key is not configured");
    }
    if (!prompt.trim()) {
      throw this.createError("NO_CONTENT", "Prompt is empty");
    }
    try {
      const languageInstructions = {
        ko: "CRITICAL LANGUAGE REQUIREMENT: ALL visible text in the image MUST be written in Korean (\uD55C\uAD6D\uC5B4). This includes the main title, all headings, labels, annotations, descriptions, and any other text elements. Do NOT use English or any other language for any text.",
        en: "CRITICAL LANGUAGE REQUIREMENT: ALL visible text in the image MUST be written in English. This includes the main title, all headings, labels, annotations, descriptions, and any other text elements.",
        ja: "CRITICAL LANGUAGE REQUIREMENT: ALL visible text in the image MUST be written in Japanese (\u65E5\u672C\u8A9E). This includes the main title, all headings, labels, annotations, descriptions, and any other text elements. Do NOT use English or any other language for any text.",
        zh: "CRITICAL LANGUAGE REQUIREMENT: ALL visible text in the image MUST be written in Chinese (\u4E2D\u6587). This includes the main title, all headings, labels, annotations, descriptions, and any other text elements. Do NOT use English or any other language for any text.",
        es: "CRITICAL LANGUAGE REQUIREMENT: ALL visible text in the image MUST be written in Spanish (Espa\xF1ol). This includes the main title, all headings, labels, annotations, descriptions, and any other text elements. Do NOT use English or any other language for any text.",
        fr: "CRITICAL LANGUAGE REQUIREMENT: ALL visible text in the image MUST be written in French (Fran\xE7ais). This includes the main title, all headings, labels, annotations, descriptions, and any other text elements. Do NOT use English or any other language for any text.",
        de: "CRITICAL LANGUAGE REQUIREMENT: ALL visible text in the image MUST be written in German (Deutsch). This includes the main title, all headings, labels, annotations, descriptions, and any other text elements. Do NOT use English or any other language for any text."
      };
      const imageSizeMap = {
        standard: "1K",
        // 1024px
        high: "2K",
        // 2048px  
        ultra: "4K"
        // 4096px (Gemini 3 Pro only)
      };
      const aspectRatio = ASPECT_RATIO_CONFIG[style];
      const imageSize = imageSizeMap[quality];
      const fullPrompt = IMAGE_GENERATION_PROMPT_TEMPLATE.replace("{style}", IMAGE_STYLES[style]).replace("{prompt}", prompt) + "\n\n" + languageInstructions[preferredLanguage];
      const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
      const generationConfig = {
        responseModalities: ["TEXT", "IMAGE"],
        imageConfig: {
          aspectRatio
        }
      };
      if (model.includes("gemini-3") || model.includes("gemini-2.5")) {
        generationConfig.imageConfig.imageSize = imageSize;
      }
      console.log("Image generation config:", JSON.stringify(generationConfig, null, 2));
      const response = await (0, import_obsidian3.requestUrl)({
        url,
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: fullPrompt
            }]
          }],
          generationConfig
        })
      });
      if (response.status !== 200) {
        throw this.handleHttpError(response.status, response.text);
      }
      const data = response.json;
      const imageData = this.extractImageFromResponse(data);
      if (!imageData) {
        throw this.createError("GENERATION_FAILED", "No image was generated. Try a different prompt or style.");
      }
      return {
        imageData: imageData.data,
        mimeType: imageData.mimeType,
        model
      };
    } catch (error) {
      if (error.type) {
        throw error;
      }
      throw this.handleApiError(error);
    }
  }
  /**
   * Extract base64 image data from Gemini API response
   */
  extractImageFromResponse(data) {
    var _a;
    try {
      const candidates = data.candidates;
      if (!candidates || candidates.length === 0) {
        return null;
      }
      const content = candidates[0].content;
      if (!content || !content.parts) {
        return null;
      }
      for (const part of content.parts) {
        if (part.inline_data) {
          return {
            data: part.inline_data.data,
            mimeType: part.inline_data.mime_type || "image/png"
          };
        }
      }
      if ((_a = content.parts[0]) == null ? void 0 : _a.inlineData) {
        return {
          data: content.parts[0].inlineData.data,
          mimeType: content.parts[0].inlineData.mimeType || "image/png"
        };
      }
      return null;
    } catch (e) {
      console.error("Error extracting image from response:", e);
      return null;
    }
  }
  handleHttpError(status, responseText) {
    if (status === 401 || status === 403) {
      return this.createError("INVALID_API_KEY", "Invalid Google API key");
    }
    if (status === 429) {
      return this.createError("RATE_LIMIT", "API rate limit exceeded. Please wait and try again.", true);
    }
    if (status === 400) {
      if (responseText.includes("SAFETY") || responseText.includes("blocked")) {
        return this.createError("CONTENT_FILTERED", "Content was blocked by safety filters. Try modifying your prompt.");
      }
      return this.createError("GENERATION_FAILED", `Bad request: ${responseText}`);
    }
    if (status >= 500) {
      return this.createError("NETWORK_ERROR", "Server error. Please try again later.", true);
    }
    return this.createError("GENERATION_FAILED", `API error (${status}): ${responseText}`);
  }
  handleApiError(error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    if (errorMessage.includes("net::") || errorMessage.includes("network")) {
      return this.createError("NETWORK_ERROR", "Network connection error. Check your internet connection.", true);
    }
    return this.createError("GENERATION_FAILED", `Image generation error: ${errorMessage}`);
  }
  createError(type, message, retryable = false) {
    return { type, message, retryable };
  }
};

// src/services/fileService.ts
var import_obsidian4 = require("obsidian");
var FileService = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Save image to the vault and return the path
   */
  async saveImage(imageData, mimeType, noteFile, attachmentFolder) {
    try {
      const extension = this.getExtensionFromMimeType(mimeType);
      const timestamp = Date.now();
      const baseName = noteFile.basename.replace(/[^a-zA-Z0-9가-힣]/g, "-");
      const fileName = `${baseName}-poster-${timestamp}.${extension}`;
      await this.ensureFolderExists(attachmentFolder);
      const imagePath = (0, import_obsidian4.normalizePath)(`${attachmentFolder}/${fileName}`);
      const binaryData = this.base64ToArrayBuffer(imageData);
      await this.app.vault.createBinary(imagePath, binaryData);
      return imagePath;
    } catch (error) {
      throw this.createError("SAVE_ERROR", `Failed to save image: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Embed image at the top of the note
   */
  async embedImageInNote(noteFile, imagePath) {
    try {
      const content = await this.app.vault.read(noteFile);
      const embedSyntax = `![[${imagePath}]]

`;
      const frontmatterMatch = content.match(/^---\n[\s\S]*?\n---\n/);
      let newContent;
      if (frontmatterMatch) {
        const frontmatter = frontmatterMatch[0];
        const restContent = content.slice(frontmatter.length);
        const existingEmbed = restContent.match(/^!\[\[.*-poster-\d+\.(png|jpg|jpeg|webp)\]\]\n\n/);
        if (existingEmbed) {
          newContent = frontmatter + embedSyntax + restContent.slice(existingEmbed[0].length);
        } else {
          newContent = frontmatter + embedSyntax + restContent;
        }
      } else {
        const existingEmbed = content.match(/^!\[\[.*-poster-\d+\.(png|jpg|jpeg|webp)\]\]\n\n/);
        if (existingEmbed) {
          newContent = embedSyntax + content.slice(existingEmbed[0].length);
        } else {
          newContent = embedSyntax + content;
        }
      }
      await this.app.vault.modify(noteFile, newContent);
    } catch (error) {
      throw this.createError("SAVE_ERROR", `Failed to embed image: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Ensure a folder exists, creating it if necessary
   */
  async ensureFolderExists(folderPath) {
    const normalizedPath = (0, import_obsidian4.normalizePath)(folderPath);
    const folder = this.app.vault.getAbstractFileByPath(normalizedPath);
    if (!folder) {
      await this.app.vault.createFolder(normalizedPath);
    } else if (!(folder instanceof import_obsidian4.TFolder)) {
      throw this.createError("SAVE_ERROR", `${folderPath} exists but is not a folder`);
    }
  }
  /**
   * Convert base64 string to ArrayBuffer
   */
  base64ToArrayBuffer(base64) {
    const binaryString = atob(base64);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes.buffer;
  }
  /**
   * Get file extension from MIME type
   */
  getExtensionFromMimeType(mimeType) {
    const mimeMap = {
      "image/png": "png",
      "image/jpeg": "jpg",
      "image/jpg": "jpg",
      "image/webp": "webp",
      "image/gif": "gif"
    };
    return mimeMap[mimeType] || "png";
  }
  createError(type, message) {
    return { type, message, retryable: false };
  }
};

// src/progressModal.ts
var import_obsidian5 = require("obsidian");
var ProgressModal = class extends import_obsidian5.Modal {
  constructor(app) {
    super(app);
    this.onCancel = null;
    this.isCancelled = false;
    this.steps = [
      { key: "analyzing", label: "\uB178\uD2B8 \uBD84\uC11D", icon: "\u{1F4C4}" },
      { key: "generating-prompt", label: "\uD504\uB86C\uD504\uD2B8 \uC0DD\uC131", icon: "\u{1F916}" },
      { key: "generating-image", label: "\uC774\uBBF8\uC9C0 \uC0DD\uC131", icon: "\u{1F3A8}" },
      { key: "saving", label: "\uD30C\uC77C \uC800\uC7A5", icon: "\u{1F4BE}" },
      { key: "embedding", label: "\uB178\uD2B8\uC5D0 \uC0BD\uC785", icon: "\u{1F4CE}" }
    ];
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("nanobanana-progress-modal");
    contentEl.createEl("h2", {
      text: "\u{1F3A8} Knowledge Poster \uC0DD\uC131 \uC911...",
      cls: "nanobanana-progress-title"
    });
    this.progressContainer = contentEl.createDiv({ cls: "nanobanana-progress-container" });
    this.progressBar = this.progressContainer.createDiv({ cls: "nanobanana-progress-bar" });
    this.progressText = this.progressContainer.createDiv({
      cls: "nanobanana-progress-text",
      text: "0%"
    });
    this.stepsContainer = contentEl.createDiv({ cls: "nanobanana-steps-container" });
    this.renderSteps();
    contentEl.createDiv({
      cls: "nanobanana-estimated-time",
      text: "\u23F1\uFE0F \uC608\uC0C1 \uC18C\uC694 \uC2DC\uAC04: \uC57D 15-30\uCD08"
    });
    const buttonContainer = contentEl.createDiv({ cls: "nanobanana-button-container" });
    this.cancelButton = buttonContainer.createEl("button", {
      text: "\uCDE8\uC18C",
      cls: "nanobanana-cancel-button"
    });
    this.cancelButton.addEventListener("click", () => {
      this.isCancelled = true;
      if (this.onCancel) {
        this.onCancel();
      }
      this.close();
    });
  }
  renderSteps() {
    this.stepsContainer.empty();
    for (const step of this.steps) {
      const stepEl = this.stepsContainer.createDiv({ cls: "nanobanana-step" });
      stepEl.createSpan({ cls: "nanobanana-step-icon", text: "\u23F3" });
      stepEl.createSpan({ cls: "nanobanana-step-label", text: `${step.icon} ${step.label}` });
      stepEl.dataset.step = step.key;
    }
  }
  updateProgress(state) {
    if (this.isCancelled)
      return;
    this.progressBar.style.width = `${state.progress}%`;
    this.progressText.setText(`${Math.round(state.progress)}%`);
    const stepIndex = this.steps.findIndex((s) => s.key === state.step);
    const stepElements = this.stepsContainer.querySelectorAll(".nanobanana-step");
    stepElements.forEach((el, index) => {
      const iconEl = el.querySelector(".nanobanana-step-icon");
      if (!iconEl)
        return;
      if (index < stepIndex) {
        el.addClass("completed");
        el.removeClass("active");
        iconEl.setText("\u2705");
      } else if (index === stepIndex) {
        el.addClass("active");
        el.removeClass("completed");
        iconEl.setText("\u{1F504}");
      } else {
        el.removeClass("active", "completed");
        iconEl.setText("\u23F3");
      }
    });
  }
  showError(error) {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("nanobanana-error-state");
    contentEl.createEl("h2", {
      text: "\u274C \uC0DD\uC131 \uC2E4\uD328",
      cls: "nanobanana-error-title"
    });
    const errorBox = contentEl.createDiv({ cls: "nanobanana-error-box" });
    errorBox.createEl("p", { text: error.message });
    if (error.details) {
      errorBox.createEl("p", {
        text: error.details,
        cls: "nanobanana-error-details"
      });
    }
    const suggestions = this.getErrorSuggestions(error);
    if (suggestions.length > 0) {
      const suggestionBox = contentEl.createDiv({ cls: "nanobanana-suggestions" });
      suggestionBox.createEl("p", { text: "\u{1F4A1} \uD574\uACB0 \uBC29\uBC95:" });
      const list = suggestionBox.createEl("ul");
      for (const suggestion of suggestions) {
        list.createEl("li", { text: suggestion });
      }
    }
    const buttonContainer = contentEl.createDiv({ cls: "nanobanana-button-container" });
    if (error.retryable) {
      const retryButton = buttonContainer.createEl("button", {
        text: "\uB2E4\uC2DC \uC2DC\uB3C4",
        cls: "nanobanana-retry-button mod-cta"
      });
      retryButton.addEventListener("click", () => {
        if (this.onCancel) {
          this.close();
        }
      });
    }
    const closeButton = buttonContainer.createEl("button", {
      text: "\uB2EB\uAE30",
      cls: "nanobanana-close-button"
    });
    closeButton.addEventListener("click", () => this.close());
  }
  showSuccess(imagePath) {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("nanobanana-success-state");
    contentEl.createEl("h2", {
      text: "\u2705 Knowledge Poster \uC0DD\uC131 \uC644\uB8CC!",
      cls: "nanobanana-success-title"
    });
    const infoBox = contentEl.createDiv({ cls: "nanobanana-success-box" });
    infoBox.createEl("p", { text: `\u{1F4C1} \uC800\uC7A5 \uC704\uCE58: ${imagePath}` });
    const buttonContainer = contentEl.createDiv({ cls: "nanobanana-button-container" });
    const closeButton = buttonContainer.createEl("button", {
      text: "\uD655\uC778",
      cls: "nanobanana-close-button mod-cta"
    });
    closeButton.addEventListener("click", () => this.close());
    setTimeout(() => {
      if (!this.isCancelled) {
        this.close();
      }
    }, 3e3);
  }
  getErrorSuggestions(error) {
    switch (error.type) {
      case "INVALID_API_KEY":
        return [
          "\uC124\uC815\uC5D0\uC11C API \uD0A4\uB97C \uD655\uC778\uD574\uC8FC\uC138\uC694",
          "API \uD0A4\uAC00 \uC62C\uBC14\uB974\uAC8C \uC785\uB825\uB418\uC5C8\uB294\uC9C0 \uD655\uC778\uD574\uC8FC\uC138\uC694",
          "\uD574\uB2F9 \uC11C\uBE44\uC2A4\uC758 API \uD0A4\uAC00 \uD65C\uC131\uD654\uB418\uC5B4 \uC788\uB294\uC9C0 \uD655\uC778\uD574\uC8FC\uC138\uC694"
        ];
      case "RATE_LIMIT":
        return [
          "\uC7A0\uC2DC \uD6C4 \uB2E4\uC2DC \uC2DC\uB3C4\uD574\uC8FC\uC138\uC694",
          "API \uC0AC\uC6A9\uB7C9 \uD55C\uB3C4\uB97C \uD655\uC778\uD574\uC8FC\uC138\uC694"
        ];
      case "NETWORK_ERROR":
        return [
          "\uC778\uD130\uB137 \uC5F0\uACB0\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694",
          "VPN\uC774\uB098 \uD504\uB85D\uC2DC \uC124\uC815\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694"
        ];
      case "GENERATION_FAILED":
        return [
          "\uB2E4\uB978 \uC2A4\uD0C0\uC77C\uB85C \uC2DC\uB3C4\uD574\uBCF4\uC138\uC694",
          "\uB178\uD2B8 \uB0B4\uC6A9\uC744 \uC218\uC815\uD558\uACE0 \uB2E4\uC2DC \uC2DC\uB3C4\uD574\uC8FC\uC138\uC694"
        ];
      case "CONTENT_FILTERED":
        return [
          "\uB178\uD2B8 \uB0B4\uC6A9\uC744 \uC218\uC815\uD574\uC8FC\uC138\uC694",
          "\uBBFC\uAC10\uD55C \uB0B4\uC6A9\uC774 \uD3EC\uD568\uB418\uC5B4 \uC788\uC744 \uC218 \uC788\uC2B5\uB2C8\uB2E4"
        ];
      case "NO_CONTENT":
        return [
          "\uB178\uD2B8\uC5D0 \uB0B4\uC6A9\uC744 \uCD94\uAC00\uD574\uC8FC\uC138\uC694"
        ];
      default:
        return [];
    }
  }
  setOnCancel(callback) {
    this.onCancel = callback;
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/previewModal.ts
var import_obsidian6 = require("obsidian");
var PreviewModal = class extends import_obsidian6.Modal {
  constructor(app, prompt, settings, onConfirm) {
    super(app);
    this.prompt = prompt;
    this.settings = settings;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("nanobanana-preview-modal");
    contentEl.createEl("h2", {
      text: "\u{1F4DD} \uD504\uB86C\uD504\uD2B8 \uBBF8\uB9AC\uBCF4\uAE30",
      cls: "nanobanana-preview-title"
    });
    const infoSection = contentEl.createDiv({ cls: "nanobanana-preview-info" });
    infoSection.createDiv({
      cls: "nanobanana-preview-info-item",
      text: `\u{1F916} \uD504\uB86C\uD504\uD2B8 \uBAA8\uB378: ${PROVIDER_CONFIGS[this.settings.selectedProvider].name} - ${this.settings.promptModel}`
    });
    infoSection.createDiv({
      cls: "nanobanana-preview-info-item",
      text: `\u{1F5BC}\uFE0F \uC774\uBBF8\uC9C0 \uBAA8\uB378: ${this.settings.imageModel}`
    });
    infoSection.createDiv({
      cls: "nanobanana-preview-info-item",
      text: `\u{1F4CA} \uC2A4\uD0C0\uC77C: ${IMAGE_STYLES[this.settings.imageStyle]}`
    });
    const textareaContainer = contentEl.createDiv({ cls: "nanobanana-textarea-container" });
    textareaContainer.createEl("label", {
      text: "\uC0DD\uC131\uB41C \uD504\uB86C\uD504\uD2B8 (\uC218\uC815 \uAC00\uB2A5):",
      cls: "nanobanana-textarea-label"
    });
    this.promptTextarea = textareaContainer.createEl("textarea", {
      cls: "nanobanana-prompt-textarea"
    });
    this.promptTextarea.value = this.prompt;
    this.promptTextarea.rows = 10;
    const charCount = textareaContainer.createDiv({ cls: "nanobanana-char-count" });
    charCount.setText(`${this.prompt.length} \uC790`);
    this.promptTextarea.addEventListener("input", () => {
      charCount.setText(`${this.promptTextarea.value.length} \uC790`);
    });
    const tipsSection = contentEl.createDiv({ cls: "nanobanana-tips" });
    tipsSection.createEl("p", { text: "\u{1F4A1} \uD301:" });
    const tipsList = tipsSection.createEl("ul");
    tipsList.createEl("li", { text: "\uD504\uB86C\uD504\uD2B8\uB97C \uC218\uC815\uD558\uC5EC \uC6D0\uD558\uB294 \uC2A4\uD0C0\uC77C\uB85C \uC870\uC815\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4" });
    tipsList.createEl("li", { text: "\uAD6C\uCCB4\uC801\uC778 \uC0C9\uC0C1, \uB808\uC774\uC544\uC6C3, \uC694\uC18C\uB97C \uCD94\uAC00\uD558\uBA74 \uB354 \uC88B\uC740 \uACB0\uACFC\uB97C \uC5BB\uC744 \uC218 \uC788\uC2B5\uB2C8\uB2E4" });
    tipsList.createEl("li", { text: '"\uB2E4\uC2DC \uC0DD\uC131" \uBC84\uD2BC\uC73C\uB85C \uC0C8\uB85C\uC6B4 \uD504\uB86C\uD504\uD2B8\uB97C \uC0DD\uC131\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4' });
    const buttonContainer = contentEl.createDiv({ cls: "nanobanana-button-container" });
    const generateButton = buttonContainer.createEl("button", {
      text: "\u{1F3A8} \uC774\uBBF8\uC9C0 \uC0DD\uC131",
      cls: "mod-cta"
    });
    generateButton.addEventListener("click", () => {
      this.onConfirm({
        confirmed: true,
        prompt: this.promptTextarea.value,
        regenerate: false
      });
      this.close();
    });
    const regenerateButton = buttonContainer.createEl("button", {
      text: "\u{1F504} \uB2E4\uC2DC \uC0DD\uC131"
    });
    regenerateButton.addEventListener("click", () => {
      this.onConfirm({
        confirmed: true,
        prompt: "",
        regenerate: true
      });
      this.close();
    });
    const cancelButton = buttonContainer.createEl("button", {
      text: "\uCDE8\uC18C"
    });
    cancelButton.addEventListener("click", () => {
      this.onConfirm({
        confirmed: false,
        prompt: "",
        regenerate: false
      });
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/main.ts
var NanoBananaPlugin = class extends import_obsidian7.Plugin {
  constructor() {
    super(...arguments);
    this.lastPrompt = "";
    this.lastNoteFile = null;
    this.isGenerating = false;
  }
  async onload() {
    await this.loadSettings();
    this.promptService = new PromptService();
    this.imageService = new ImageService();
    this.fileService = new FileService(this.app);
    this.addCommand({
      id: "generate-knowledge-poster",
      name: "Generate Knowledge Poster",
      callback: () => this.generatePoster()
    });
    this.addCommand({
      id: "generate-prompt-only",
      name: "Generate Prompt Only (Copy to Clipboard)",
      callback: () => this.generatePromptOnly()
    });
    this.addCommand({
      id: "regenerate-last-poster",
      name: "Regenerate Last Poster",
      callback: () => this.regenerateLastPoster()
    });
    this.addSettingTab(new NanoBananaSettingTab(this.app, this));
    console.log("NanoBanana PRO loaded");
  }
  onunload() {
    console.log("NanoBanana PRO unloaded");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * Main generation flow
   */
  async generatePoster() {
    if (this.isGenerating) {
      new import_obsidian7.Notice("Generation already in progress");
      return;
    }
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian7.MarkdownView);
    if (!activeView || !activeView.file) {
      new import_obsidian7.Notice("Please open a note first");
      return;
    }
    const noteFile = activeView.file;
    const noteContent = await this.app.vault.read(noteFile);
    if (!noteContent.trim()) {
      new import_obsidian7.Notice("Note is empty. Please add some content first.");
      return;
    }
    if (!this.settings.googleApiKey) {
      new import_obsidian7.Notice("Google API key is required for image generation. Please configure it in settings.");
      return;
    }
    const providerKey = this.getProviderApiKey();
    if (!providerKey) {
      new import_obsidian7.Notice(`${this.settings.selectedProvider} API key is not configured. Please check settings.`);
      return;
    }
    this.isGenerating = true;
    this.lastNoteFile = noteFile;
    let progressModal = null;
    try {
      if (this.settings.showProgressModal) {
        progressModal = new ProgressModal(this.app);
        progressModal.open();
      }
      this.updateProgress(progressModal, {
        step: "generating-prompt",
        progress: 20,
        message: "\uD504\uB86C\uD504\uD2B8 \uC0DD\uC131 \uC911..."
      });
      const promptResult = await this.executeWithRetry(async () => {
        return await this.promptService.generatePrompt(
          noteContent,
          this.settings.selectedProvider,
          this.settings.promptModel,
          providerKey,
          this.settings.imageStyle,
          this.settings.preferredLanguage
        );
      });
      let finalPrompt = promptResult.prompt;
      this.lastPrompt = finalPrompt;
      if (this.settings.customPromptPrefix) {
        finalPrompt = `${this.settings.customPromptPrefix}

${finalPrompt}`;
      }
      if (this.settings.showPreviewBeforeGeneration) {
        if (progressModal) {
          progressModal.close();
          progressModal = null;
        }
        const previewResult = await this.showPreviewModal(finalPrompt);
        if (!previewResult.confirmed) {
          this.isGenerating = false;
          return;
        }
        if (previewResult.regenerate) {
          this.isGenerating = false;
          return this.generatePoster();
        }
        finalPrompt = previewResult.prompt;
        if (this.settings.showProgressModal) {
          progressModal = new ProgressModal(this.app);
          progressModal.open();
        }
      }
      this.updateProgress(progressModal, {
        step: "generating-image",
        progress: 50,
        message: "\uC774\uBBF8\uC9C0 \uC0DD\uC131 \uC911..."
      });
      const imageResult = await this.executeWithRetry(async () => {
        return await this.imageService.generateImage(
          finalPrompt,
          this.settings.googleApiKey,
          this.settings.imageModel,
          this.settings.imageStyle,
          this.settings.preferredLanguage,
          this.settings.imageQuality
        );
      });
      this.updateProgress(progressModal, {
        step: "saving",
        progress: 80,
        message: "\uD30C\uC77C \uC800\uC7A5 \uC911..."
      });
      const imagePath = await this.fileService.saveImage(
        imageResult.imageData,
        imageResult.mimeType,
        noteFile,
        this.settings.attachmentFolder
      );
      this.updateProgress(progressModal, {
        step: "embedding",
        progress: 95,
        message: "\uB178\uD2B8\uC5D0 \uC0BD\uC785 \uC911..."
      });
      await this.fileService.embedImageInNote(noteFile, imagePath);
      this.updateProgress(progressModal, {
        step: "complete",
        progress: 100,
        message: "\uC644\uB8CC!"
      });
      if (progressModal) {
        progressModal.showSuccess(imagePath);
      } else {
        new import_obsidian7.Notice("\u2705 Knowledge Poster generated successfully!");
      }
    } catch (error) {
      const genError = error;
      if (progressModal) {
        progressModal.showError(genError);
      } else {
        new import_obsidian7.Notice(`\u274C Generation failed: ${genError.message}`);
      }
      console.error("NanoBanana PRO error:", error);
    } finally {
      this.isGenerating = false;
    }
  }
  /**
   * Generate prompt only and copy to clipboard
   */
  async generatePromptOnly() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian7.MarkdownView);
    if (!activeView || !activeView.file) {
      new import_obsidian7.Notice("Please open a note first");
      return;
    }
    const noteContent = await this.app.vault.read(activeView.file);
    if (!noteContent.trim()) {
      new import_obsidian7.Notice("Note is empty");
      return;
    }
    const providerKey = this.getProviderApiKey();
    if (!providerKey) {
      new import_obsidian7.Notice(`${this.settings.selectedProvider} API key is not configured`);
      return;
    }
    try {
      new import_obsidian7.Notice("Generating prompt...");
      const result = await this.promptService.generatePrompt(
        noteContent,
        this.settings.selectedProvider,
        this.settings.promptModel,
        providerKey,
        this.settings.imageStyle,
        this.settings.preferredLanguage
      );
      await navigator.clipboard.writeText(result.prompt);
      this.lastPrompt = result.prompt;
      new import_obsidian7.Notice("\u2705 Prompt copied to clipboard!");
    } catch (error) {
      const genError = error;
      new import_obsidian7.Notice(`\u274C Failed: ${genError.message}`);
    }
  }
  /**
   * Regenerate using the last prompt
   */
  async regenerateLastPoster() {
    if (!this.lastPrompt) {
      new import_obsidian7.Notice("No previous generation found. Please generate a poster first.");
      return;
    }
    if (!this.lastNoteFile) {
      new import_obsidian7.Notice("Original note not found. Please generate a new poster.");
      return;
    }
    const file = this.app.vault.getAbstractFileByPath(this.lastNoteFile.path);
    if (!file || !(file instanceof import_obsidian7.TFile)) {
      new import_obsidian7.Notice("Original note was moved or deleted");
      return;
    }
    if (this.isGenerating) {
      new import_obsidian7.Notice("Generation already in progress");
      return;
    }
    this.isGenerating = true;
    let progressModal = null;
    try {
      if (this.settings.showProgressModal) {
        progressModal = new ProgressModal(this.app);
        progressModal.open();
      }
      this.updateProgress(progressModal, {
        step: "generating-image",
        progress: 40,
        message: "\uC774\uBBF8\uC9C0 \uC0DD\uC131 \uC911..."
      });
      const imageResult = await this.executeWithRetry(async () => {
        return await this.imageService.generateImage(
          this.lastPrompt,
          this.settings.googleApiKey,
          this.settings.imageModel,
          this.settings.imageStyle,
          this.settings.preferredLanguage,
          this.settings.imageQuality
        );
      });
      this.updateProgress(progressModal, {
        step: "saving",
        progress: 80,
        message: "\uD30C\uC77C \uC800\uC7A5 \uC911..."
      });
      const imagePath = await this.fileService.saveImage(
        imageResult.imageData,
        imageResult.mimeType,
        this.lastNoteFile,
        this.settings.attachmentFolder
      );
      this.updateProgress(progressModal, {
        step: "embedding",
        progress: 95,
        message: "\uB178\uD2B8\uC5D0 \uC0BD\uC785 \uC911..."
      });
      await this.fileService.embedImageInNote(this.lastNoteFile, imagePath);
      if (progressModal) {
        progressModal.showSuccess(imagePath);
      } else {
        new import_obsidian7.Notice("\u2705 Poster regenerated successfully!");
      }
    } catch (error) {
      const genError = error;
      if (progressModal) {
        progressModal.showError(genError);
      } else {
        new import_obsidian7.Notice(`\u274C Regeneration failed: ${genError.message}`);
      }
    } finally {
      this.isGenerating = false;
    }
  }
  /**
   * Show preview modal and wait for user decision
   */
  showPreviewModal(prompt) {
    return new Promise((resolve) => {
      const modal = new PreviewModal(
        this.app,
        prompt,
        this.settings,
        (result) => resolve(result)
      );
      modal.open();
    });
  }
  /**
   * Execute operation with auto-retry
   */
  async executeWithRetry(operation) {
    let lastError = null;
    for (let attempt = 0; attempt <= this.settings.autoRetryCount; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;
        if (!lastError.retryable || attempt === this.settings.autoRetryCount) {
          throw lastError;
        }
        const delay = Math.pow(2, attempt) * 1e3;
        await this.sleep(delay);
      }
    }
    throw lastError;
  }
  /**
   * Update progress modal
   */
  updateProgress(modal, state) {
    if (modal) {
      modal.updateProgress(state);
    }
  }
  /**
   * Get API key for the selected provider
   */
  getProviderApiKey() {
    switch (this.settings.selectedProvider) {
      case "openai":
        return this.settings.openaiApiKey;
      case "google":
        return this.settings.googleApiKey;
      case "anthropic":
        return this.settings.anthropicApiKey;
      case "xai":
        return this.settings.xaiApiKey;
      default:
        return "";
    }
  }
  /**
   * Sleep utility
   */
  sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
};
